## 2. 생성자 하나를 주 생성자로 만드세요
생성자는 새로운 객체에 대한 진입점이다.  
몇 개의 인자를 전달받아 이들을 이용해 어떤 일을 수행한 후, 객체가 자신의 의무를 수행할 수 있도록 준비한다.  

<br>

> **많은 수의 생성자와 적은 수의 메서드**

```kotlin
Cash(30)
Cash("$29.95")
Cash(29.95f)
Cash(29.95, "USD")
```

올바르게 클래스를 설계한다면, 클래스는 많은 수의 생성자와 적은 수의 메서드를 포함하여 응집도가 높고 견고해진다.  
생성자가 많아질 수록 **클라이언트가 클래스를 더 유연하게 사용**할 수 있다.  
이러한 유연성 덕분에 작성해야 하는 코드는 적어지고, 중복 코드의 양도 줄어든다.  
하지만 메서드가 많아질 수록 클래스를 사용하기는 더 어려워지고, SRP를 위반한다.  

<br>
<br>

> **하나의 주 생성자와 다수의 부 생성자**

생성자의 주된 임무는 제공된 인자를 사용해서 캡슐화된 프로퍼티를 초기화하는 것이다.  
**초기화 로직을 오직 하나의 생성자(주 생성자)에만 위치**시키고,  
**다른 생성자(부 생성자)는 이러한 주 생성자를 호출**하도록 만들어라.  

<br>

```kotlin
class Cash(private val dollars: Int) { // 주 생성자
    constructor(dlr: Double) : this(dlr.toInt()) // 부 생성자
    
    constructor(dlr: String) : this(Cash.parse(dlr)) // 부 생성자
}
```
위 예제에서 주 생성자는 인자로 전달된 정수를 이용해 프로퍼티를 초기화만 한다.  
부 생성자에서 파싱이나 변환을 통해 주 생성자로 전달할 정수형 인자를 준비한다.  


"하나의 주 생성자와 다수의 부 생성자" 원칙의 요점은,  
중복 코드를 방지하고 설계를 더 간결하게 만들어 유지보수성이 향상된다는 것이다.  
주 생성자에서만 프로퍼티를 초기화해야 한다는 원칙을 따르지 않고 구현한 코드를 보자.  

<br>
 
```kotlin
class Cash {
    private int dollars;
    
    Cash(float dlr) {
        this.dollars = (int) dlr;
    }
    
    Cash(String dlr) {
        this.dollars = Cash.parse(dlr);
    }

    Cash(int dlr) {
        this.dollars = dlr;
    }
}
```

(코틀린에서는 부 생성자들이 주 생성자를 무조건 호출해야 하므로 이 예제에서는 자바 언어를 사용했다.)  


여기에서 dollars의 값이 항상 양수여야 한다고 가정해보자.  
이를 보장하기 위해서는 세 개의 생성자 안에 일일이 유효성 검사 로직을 작성해야 한다.  
하지만 하나의 주 생성자와 두 개의 부 생성자를 구현한 이전 예제에서는 **유효성 검사 로직을 주생성자 한 장소에만 추가**하면 된다.  

<br>

```
하나의 주 생성자와 여러 개의 부 생성자를 생성하라.
주 생성자에는 프로퍼티를 전달받은 인자로 초기화만 하고,
부 생성자에서는 전달받은 인자를 준비(포맷팅, 파싱, 변환)하여 주 생성자를 호출한다.
```