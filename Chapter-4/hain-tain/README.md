# 4장. 은퇴

### 📌 인상 깊었던 점

- (157p.) 문제를 더 빨리 발견할수록 문제를 수정하는 시간 역시 빨라집니다. 버그가 더 빨리 드러날수록 더 신속하게 대응할 수 있고 모든 버그 수정은 제품을 좀 더 안정적이고 견고하게 만듭니다.
- (166-167p.) 항상 예외를 체이닝하세요. 예외를 잡은 즉시 원래의 문제를 새로운 문제로 감싸서 함께 상위로 던집니다. 체이닝이 여러 번 발생한다면, 위로 전파되는 예외는 내부에 다른 비눗방울을 포함하여 더 커다란 비눗방울처럼 보일 것입니다. 예외 체이님은 의미론적으로 문제와 관련된 문맥을 풍부하게 만든다는 것입니다.
- (177p.) 우리는 의도를 명확하게 표현해야 합니다. 매서드는 올바른 방식으로 설계되거나, 아니면 아예 설계되지 말아야 합니다.

### 🤔 궁금한 점

- (158p.) "아무것도 발견하지 못할 경우 빈 컬렉션을 반환합니다. 기술적으로 이 방법은 NULL 과 크게 다르지 않지만 조금 더 깔끔합니다." => 어디가, 어떤 의미로 깔끔해졌다는 것일까? null 이나 빈배열(빈 컬렉션)이나 결국 같은 거 아닐까? 해당 컬렉션에서 아무것도 해주지 않는다면 null 과 다를바 없는데 무슨 의미가 있나...?

- (179p.) 아래 코드 아랫부분에 "try 블록의 아이디어는 C++의 파괴자와 매우 유사합니다. 간단하게 Text 클래스가 Closable 인터페이스를 구현하게 하면 됩니다." 라는 부분이 있다.

  - 질문 1: try 블록의 아이디어는 클로저를 이용해서 t의 유효범위를 설정해준 것으로 close 했다고 한것인가?
  - 질문 2: Closable 인터페이스를 구현하게 한다는 것은 무엇인가?

  ```java
  int main(){
      try(Text t= new Text("/tmp/test.txt")){
          t.content();
      }
  }
  ```

### 🔗 적용해보면 좋을 점

- Null을 인자로 넘겨주지도, 반환하지도 말자! (그냥 null이 없다고 생각하자!)
- 객체 내부에서 원하지 않은 입력이 들어오거나, 출력을 할 경우 그냥 예외를 발생시키자
- 예외를 체이닝하자

### 💚 느낀 점

- 순식간에 스터디가 끝난 것 같은 느낌이 든다. 여전히 객체지향이 어렵게 느껴지지만 그래도 그 이전에는 생각조차 해보지 못했던 시도들을 해볼 수 있어서 즐거운 것 같다. 무엇보다 객체와 각 매서드의 역할과 책임에 대해 묻고, 명확하게 하려고 노력하는 태도가 이 스터디를 통해 얻은 가장 큰 자산이라고 생각한다.
- 1장부터 4장까지 꽤나 많은 규칙들을 이야기하고 있는데, 이것을 전부 단 번에 지키려고 하기보다는, 하나씩 차례차례 적용해보아야겠다. 일단 static 키워드와 null은 그냥 없다고 생각하고 살아야겠다.
