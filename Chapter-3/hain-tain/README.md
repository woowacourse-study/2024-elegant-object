# 3장. 직장생활

### 📌 인상 깊었던 점

- (94p.) 각 매서드가 클래스의 모든 프로퍼티를 사용하게 됩니다. 그리고 이것이 응집도의 정의이기도 합니다. 두 개의 프로퍼티를 포함하는 클래스가 있을 때, 하나의 프로퍼티는 두 개의 매서드에서만 사용하고 다른 하나의 프로퍼티는 다른 세 개의 매서드에서만 사용하고 있다면, 이 클래스는 거의 연관성이 없는 독립적인 두 부분이 한데 뭉쳐있는 상태라고 볼 수 있습니다. 이런 클래스는 응집도가 낮습니다.
- (98p.) 함수형, 논리형, 객체지향 프로그래밍이 절차적 프로그래밍과 차별화되는 점이 바로 이 ‘is a’ 입니다. 객체지향적으로 생각하기에서는 누가 누구인지만 우리가 정의하고, 객체들이 필요에 따라 스스로 상호작용합니다.
- (112p.) 유틸리티 클래스와 싱글턴 클래스를 구분하는 핵심적인 차이점은, 유틸리티 클래스는 끊기가 불가능한 하드코딩된 결합도를 가지는 반면 싱글톤은 getInstance() 와 함께 setInstance()를 추가할 수 있다는 것입니다. (중략) 유틸리티 클래스 안에는 객체가 존재하지 않습니다. 따라서 어떤 것도 변경할 수 없습니다. 유틸리티 클래스는 끊을 수 없는 하드코딩된 의존성을 의미합니다.
- (114p.) 클래스가 작업을 수항해는데 필요한 모든 것은 생성자에게 제공되어야 하고 내부에 캡슐화되어야 합니다. 예외는 없습니다. 객체는 자신이 캡슐화하고 있는 프로퍼티 이외의 어떤 것도 건드려서는 안됩니다.
- (127p.) 식별자는 f를 다른 객체와 구별하는 것이고, 상태는 f가 파일에 대해 알고 있는 것이며, 행동은 요청에 대해 f가 할 수 있는 것을 뜻합니다. 가변 객체와 불변 객체의 중요한 차이점은 불변 객체에는 식별자가 존재하지 않으며, 상태가 결코 변하지 않는다는 것입니다. 불변 객체의 식별자는 객체의 상태와 완전히 동일합니다.
- (136p.) 자료구조는 투명하지만, 객체는 불투명합니다. 자료구조는 수동적이지만, 객체는 능동적입니다. 자료구조는 죽어있지만, 객체는 살아 숨쉽니다.
- (137p.) 객채는 일급 시민이며, 생성자를 통한 객체의 초기화가 곧 소프트웨어입니다. 연산자나 구문이 아니라 바로 생성자가 말입니다.

### 🤔 궁금한 점

- (101p.) 선언만 해둔 것은 OK. 그런데 그렇다면 y는 y를 사용할 때 계산이 되는가? 실행을 어떻게 제어할 수 있을까..?
- (102p.) 만약 객체(인스턴스)를 생성하는 것이 아니라 생성된 인스턴스의 매서드를 불러야 하는 경우라면 정적 매서드와 성능상으로는 다를 바가 없는 것 아닐까?
- (113p.) 전역 변수는 캡슐화를 완벽하게 위반하기때문에 나쁘다는 것은 알겠다. 그런데 만약, 전역 변수처럼 여기저기서 다 써야하는 상태가 있다면 어떻게 해야할까? props drilling 으로 계속 내려주는 것밖에 방법이 없을 것 같은데, 그게 더 가독성도 좋지 않고, 무엇보다 중간 다리 역할을 하는 객체에서는 해당 매서드가 필요하지 않은데 그저 아래 계층으로 상태를 전달하기 위해, 생성자에서 인자를 받고, 매서드를 생성하는 것이 맞는 것일까? 어떻게 개선할 수 있을까?
- (148p.) 기술적으로 런타임에 객체의 타입을 조사하는 것은 클래스 사이의 결합도를 높이기 때문에 좋지 않다고 한다, 그런데 타입스크립트를 사용하면 오히려 ‘타입 Narrowing’을 위해 타입을 확인하게 된다. 타입 Narrowing도 지양해야 할까? (타입 Narrowing 이 반드시 필요하다면, 타입을 확인하는 객체를 만들어서 넣어줘야 하나? 아니면 무조건 해당 타입을 반환하는 객체를 만들어서 넣어줘야하나…?)

### 🔗 적용해보면 좋을 점

- 퍼블릭 매서드는 최대 5개까지만!
- static 은 그냥 없다고 생각할 것!
- null을 인자로 넣지 말것! 꼭 필요한 경우에는 null의 역할을 해주는 객체를 만들어서 전달할 것!
- 생성자 내부에서 상태를 모두 초기화해줄것! 또한 상태를 변경할 땐, 새 객체를 선언해서 할당해줄 것!

### 💚 느낀 점

- 프리코스에서 처음으로 ‘클래스’를 접하고, 클래스를 사용하여 프로그래밍을 해보았다. 그때 내가 느낀 것은, 클래스란 나만의 자료구조를 정의할 수 있는 방법이라고 생각했다. (저자가 보면 객체에게 너무 무례하며, 그건 객체가 아니라고 말했을 것이다.) 이외에도 Inputview와 Outputview라는 이름의 정적매서드의 집합, 유틸리티 함수를 만들어 사용하기도 했다. 그때 나에게 객체란 자료구조의 종류였으며, 클래스란 그저 내부의 전역 상태와 함수를 만들 수 있는 커스텀 가능한 신기한 존재였다.
- <엘레강트 오브젝트> 와 <객체지향의 사실과 오해> 책을 읽으면서, 객체 지향이란 무엇인지, 왜 객체 지향이 나오게 되었는지를 알게되었고, 흥미로웠다. 컴퓨터처럼 사고하는 것이 아니라, 우리가 세상을 보고 이해하는 관점으로 프로그래밍을 한다는 점이 좋았다. 각 객체가 각자의 책임을 가지고, 자율적으로 행동하게 한다는 것도 좋았다.
- 요즘 컴포넌트를 객체로 관리하고 있는데, 컴포넌트를 객체로 관리하게 된 이유는 아래 코드가 훨씬 가독성이 좋고, 컴포넌트가 자율적이고 능동적으로 행동한다는 느낌을 주기 때문이다.
  ```js
  handleModalOpen(addRestaurantModal);
  ```
  ```js
  addRestaurantModal.open();
  ```
- 원래 공부를 열심히 하면, 아는 게 늘어나야 하는데… 책을 읽고 공부를 할 수록 더 선명하게 모르겠다. 적용은 더더욱 어렵다., 이 책에 나오는 원칙들을 거의 지키지 못하고 있다. 퍼블릭 매서드 5개는 무슨 7~8개씩 담고있고, 거의 대부분 조정자를 통해 상태를 변경하는 가변 객체이다. 그럼에도 불구하고, 객체 지향이 추구하는 가치에 동의하고 시도해보기로 마음 먹었으므로, 일단 돌아가는 쓰레기를 만든 다음 찬찬히 리펙토링을 해나가야겠다.