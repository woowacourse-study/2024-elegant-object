## 엘레강트 오브젝트 스터디 3회차 피드백 정리
### 3.2
- 선언적 프로그래밍
  - FP와 OOP는 선언적이다. 선언적인 측면에서 OOP는 FP와 유사하다.
  - SOLID 원칙은 객체지향만의 원칙이 아니고, 함수형에서도 적용이 된다.
  - `Max(1, 100)`와 `Max(1, 100)`는 같다. (언어적인 관점이 아닌, 객체지향적 관점에서)
  - `Max(1, 100)`와 `Max(10, 1000)`는 다르다.
	  - 객체 내부에서 실제로 값을 비교하는 메서드의 결과는 같지만, 객체 자체는 다르다.
	  - 다르다는 것을 보장하기 위해서는, 생성자에 코드가 들어가서는 안 된다.
	  - 생성자에 계산하는 코드가 들어가면, 두 객체는 같아질 수 있다.

<br>

- 싱글톤
  - 싱글톤은 상수 객체인 경우에만 사용한다.
  - 가변적인 객체를 싱글톤으로 선언하면, 여러곳에서 객체의 상태를 변경할 수 있고, 결국 상태 관리가 힘들어진다.

<br>

- 유틸리티 클래스
	- 언어적 관점, 프레임워크 관점에서만 보지말자. 
		- (ex: 안드로이드의 `WorkManager`는 -er로 끝나는데, 이건 좋지 않은 클래스인가?, 현실적으로 가능할까?)
	- 프레임워크가 `순수 객체지향 관점`을 가지고 개발하지 않았을 수 있다. 내가 계속해서 관리할 코드와, 그렇지 않은 코드를 구분하자.
	- 앞으로 프레임워크를 사용하면서 객체지향 원칙을 어길 수 있다. 객체지향 원칙을 어기는 코드를 최대한 줄이는 것이 우리의 목표!

<br>

### 3.3
- null은 필연적으로 등장할 수밖에 없다. (ex: kotlin에서의 `toIntOrNull()`)
- null을 아예 사용하지 않는 것이 아니라, 빠르게 null이 아닌 값으로 변경하는 것이 중요하다.
	- null 객체를 사용
	- 기본값을 셋팅
	- 예외를 다시 throw
- null 객체도 디자인 패턴 중 하나다. 
- (ex: 오목 미션에서 돌이 놓아져있지 않은 경우를 `NoneStone`으로 표현)

<br>

### 3.4
- Compose에서, 상태 변화를 감지해서 ui를 계속 다시 그린다. (상태가 변했다면 다시 그리고, 변하지 않았다면 그리지 않는다.)
- ui를 다시 그리는 과정은 비용이 크기 때문에, 재사용할 부분과 다시 그릴 부분을 구분한다.
- 이를 구분하는 가장 큰 기준은 `상수 객체인지 아닌지`가 된다.

<br>

### 3.5
- getter를 사용해야 할 시점을 명확히 구분해야 한다.
- model에서의 getter는 view, controller를 위해서만 사용한다.
- 즉, model만 놓고 봤을 때 getter는 사용하지 않아야 한다.

<br>

- `객체의 행동적 관점`에서 setter가 필요한 상황이 있다. 
- 단순히 객체의 상태를 초기화, 설정해주는 함수를 만들지 말자. 객체의 행동에 따라 상태를 변경하는 것은 Ok
- `setXXX()`와 `changeXXX()`는 느낌이 다르다. 객체의 상태를 변경하는 함수의 네이밍도 중요하다.

<br>

### 3.6
- 인트로스펙션 -> 코틀린에서의 `is`
- 타입 캐스팅 대신, 수많은 `isXXX()`함수가 생기는 것은 괜찮은가? 
- 즉, 어떤 타입인지 검사하는 함수들이 여러개 생기는 것을 어떻게 해결할 것인가?
- -> `다형성`
