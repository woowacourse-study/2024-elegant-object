> 113p. 절대로 싱글톤을 사용하지 마세요. 싱글톤에 대해 생각조차 하지 마세요. (...) 그렇다면 대안은 뭘까요? 소프트웨어에 포함된 전체 클래스들이 사용해야 하는 기능은 어떻게 구현해야 할까요? (...) 클래스가 작업을 수행하는데 필요한 모든 것은 생성자에 제공되어야 하고 내부에 캡슐화되어야 합니다.

싱글톤이 나쁘다는 건 알겠다.
싱글톤은 전역 변수와 유사하고, 전역 변수는 절차적인 언어를 위한 장치이기 때문이다.
그런데 싱글톤 대신 사용해야 할 방법은 `캡슐화`라고 하는데, 어떤 소리인지 이해가 안 간다.
<br>

또한 현실적으로 싱글톤을 아예 사용하지 않을 수 있을까? 
만약 인스턴스를 생성하는 비용이 크다면, 매번 인스턴스를 생성하는 것보다 싱글톤을 사용하는 것이 더 효율적일 것이다. (생성자에 코드가 없어야 하니까 **인스턴스의 생성 비용이 크다는 것**부터 이상한 코드인 걸까?)

<br>
<br>

> 115p. 이상적인 OOP 언어는 클래스와 함수를 포함해야 합니다. 클래스는 마이크로 프로시저(micro-procedures)인 Java 메서드를 포함해서는 안됩니다. 순수한 FP 패러다임에서 말하는 오직 하나의 출구(exit point)만 가지는 진정한 함수를 포함해야 합니다. 이것이 FP를 OOP에 접목시킨 이상적인 상황일 것입니다.

> 126p. 비록 객체는 상수가 아니지만, 표현하는 엔티티에 '충성스럽기(loyal)' 때문에, 이 객체는 불변 객체입니다.

> 128p. 불변 객체는 좌표를 알고 있고, 우리는 그 좌표를 상태라고 부릅니다. (...) 실세계가 정말로 '실재하기(real)' 때문입니다. 실세계 엔티티는 소프트웨어 외부 어딘가에 존재합니다. 따라서 엔티티와 대표자를 쉽게 분리할 수 있습니다.

무슨 소리인지 이해를 못 했다.

<br>
<br>

> 127p. 객체 팩토리로서의 역할을 수행하는 완벽한 클래스 구현은 이런 특징을 이해하고 동일한 상태를 캡슐화하는 중복된 인스턴스를 생성하지 말아야 합니다.

나는 이 방식을 **인스턴스 캐싱**하는 것이라고 생각했다. 
캐싱을 하려면 static 팩토리 메서드를 생성해야 한다. 
그런데 이 책에서는 팩토리 메서드도 지양하라고 하고, static 메서드도 지양하라고 한다. 
위 문장의 의도를 잘 모르겠다. 
언어 차원에서 중복된 인스턴스를 생성하지 말아야 한다는 말인가?

<br>
<br>

> 128p. 우리는 오직 불변 객체만을 가질 것이고, 따라서 equals()와 hashCode() 메서드도 필요하지 않을 것입니다.

불변 객체는 상태를 통해 객체를 식별한다고 이해했다. 
즉, 같은 상태의 객체라면 같은 객체가 된다.
그런데 왜 `equals()`와 `hashCode()`가 필요하지 않은 거지?
오히려 상태를 통해 객체를 식별하려면 `equals()`와 `hashCode()`를 오버라이드 해야 하는 것 아닌가?

<br>
<br>

> 129p. 객체의 상태가 객체가 대표하는 실제 엔티티와 동일한 특별한 경우에는, '불변' 대신 '상수(constant)'라는 용어를 사용할 것을 제안합니다.

`객체의 상태가 객체가 대표하는 실제 엔티티와 동일한 경우` -> 
원시값 포장이나 일급 컬렉션을 떠올렸다.
내가 잘 이해했는지 모르겠다. 
그런데 여기서 말하는 엔티티가 뭐지? 
서치해봐도 백엔드 관련 엔티티만 나와서 모르겠음.
- 값이 같아도 다른 객체라고 취급한다.
- 고유한 식별성을 가진다.
- 가변 객체
