> 113p. 절대로 싱글톤을 사용하지 마세요. 싱글톤에 대해 생각조차 하지 마세요. (...) 그렇다면 대안은 뭘까요? 소프트웨어에 포함된 전체 클래스들이 사용해야 하는 기능은 어떻게 구현해야 할까요? (...) 클래스가 작업을 수행하는데 필요한 모든 것은 생성자에 제공되어야 하고 내부에 캡슐화되어야 합니다.

싱글톤이 나쁘다는 건 알겠다.
싱글톤은 전역 변수와 유사하고, 전역 변수는 절차적인 언어를 위한 장치이기 때문이다.
그런데 싱글톤 대신 사용해야 할 방법은 `캡슐화`라고 하는데, 어떤 소리인지 이해가 안 간다.
<br>

**-> 전역적으로 사용해야 할 객체를 파라미터로 전달하여 캡슐화하는 방식. 그러면 객체를 사용하기 위해 전달하는 depth가 깊어질 수 있을 것 같다.**

<br>

또한 현실적으로 싱글톤을 아예 사용하지 않을 수 있을까? 
만약 인스턴스를 생성하는 비용이 크다면, 매번 인스턴스를 생성하는 것보다 싱글톤을 사용하는 것이 더 효율적일 것이다. (생성자에 코드가 없어야 하니까 **인스턴스의 생성 비용이 크다는 것**부터 이상한 코드인 걸까?)

**-> 싱글톤은 상수 객체인 경우에만 사용한다. 가변적인 객체를 싱글톤으로 선언하면, 여러곳에서 객체의 상태를 변경할 수 있고, 결국 상태 관리가 힘들어진다.**

<br>

<br>

> 115p. 이상적인 OOP 언어는 클래스와 함수를 포함해야 합니다. 클래스는 마이크로 프로시저(micro-procedures)인 Java 메서드를 포함해서는 안됩니다. 순수한 FP 패러다임에서 말하는 오직 하나의 출구(exit point)만 가지는 진정한 함수를 포함해야 합니다. 이것이 FP를 OOP에 접목시킨 이상적인 상황일 것입니다.

**-> 책에서 말하는 `마이크로 프로시저(micro-procedures)`는 side-effect가 많은 함수들을 말한다. 
`순수한 FP 패러다임에서 말하는 오직 하나의 출구(exit point)만 가지는 진정한 함수`는, 입력과 출력이 명확한 순수 함수를 뜻한다. (참고: https://www.youtube.com/watch?v=e-5obm1G_FY)**

<br>

<br>

> 128p. 불변 객체는 좌표를 알고 있고, 우리는 그 좌표를 상태라고 부릅니다. (...) 실세계가 정말로 '실재하기(real)' 때문입니다. 실세계 엔티티는 소프트웨어 외부 어딘가에 존재합니다. 따라서 엔티티와 대표자를 쉽게 분리할 수 있습니다.

**책에서 말하는 `엔티티` -> 실세계를 그대로 반영하고 있는 것.**

<br>

<br>

> 127p. 객체 팩토리로서의 역할을 수행하는 완벽한 클래스 구현은 이런 특징을 이해하고 동일한 상태를 캡슐화하는 중복된 인스턴스를 생성하지 말아야 합니다.

나는 이 방식을 **인스턴스 캐싱**하는 것이라고 생각했다. 
캐싱을 하려면 static 팩토리 메서드를 생성해야 한다. 
그런데 이 책에서는 팩토리 메서드도 지양하라고 하고, static 메서드도 지양하라고 한다. 
위 문장의 의도를 잘 모르겠다. 
언어 차원에서 중복된 인스턴스를 생성하지 말아야 한다는 말인가?

**-> 기술적인 관점이 아니라, 순수 객체지향적 관점에서 중복된 인스턴스를 생성하지 말아야 한다는 의미다.**

<br>

<br>

> 128p. 우리는 오직 불변 객체만을 가질 것이고, 따라서 equals()와 hashCode() 메서드도 필요하지 않을 것입니다.

불변 객체는 상태를 통해 객체를 식별한다고 이해했다. 
즉, 같은 상태의 객체라면 같은 객체가 된다.
그런데 왜 `equals()`와 `hashCode()`가 필요하지 않은 거지?
오히려 상태를 통해 객체를 식별하려면 `equals()`와 `hashCode()`를 오버라이드 해야 하는 것 아닌가?

**-> 우리가 사용하는 언어는 상태가 같아도 다른 주소값을 가질 수 있지만, 저자는 언어 차원에서 상태가 같으면 같은 주소값을 가리키도록 해야 한다고 말한다. (위 질문과 연결지어 생각하기)**

<br>

<br>

> 129p. 객체의 상태가 객체가 대표하는 실제 엔티티와 동일한 특별한 경우에는, '불변' 대신 '상수(constant)'라는 용어를 사용할 것을 제안합니다.

`객체의 상태가 객체가 대표하는 실제 엔티티와 동일한 경우` -> 
원시값 포장이나 일급 컬렉션을 떠올렸다. 내가 잘 이해했는지 모르겠다.  

**-> 잘 이해한 거 맞음.**
